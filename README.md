<h1>Курсовой проект по императивному программированию на языке Си (1 курс).</h1>

Здесь представлен проект "Архиватор по алгоритму Хаффмана".
<br>
<h3>Что он делает?</h3>
<ul>
  <li>Принимает на вход 1 файл, выдает на выход сжатый файл.</li>
  <li>Принимает на вход 1 сжатый файл, возвращает его в исходный вид.</li>
  <li>По команде --help выдает инструкцию.</li>
</ul>
<br>
<h3>Кратко об алгоритме Хаффмана:</h3>
<ol>
  <li>Выбираем размер символов, который мы будем считывать (в моем случае – 8 бит, char)</li>
  <li>Для каждого символа подсчитываем, сколько раз он встречается в файле</li>
  <li>Составляем очередь с приоритетом (в начале символы с меньшей частотой)</li>
  <li>Пока очередь не закончилась, объединяем два наименьших по частоте элемента в дерево так, что эти элементы – “листья” (даже если элемент – дерево), присваиваем новому дереву суммарный вес объединенных элементов, перемещаем его в очереди на нужное место по приоритету</li>
  <li>Составляем кодировку всех символов, идя от корня дерева вниз, добавляя бит 1 для элементов справа от корня, бит 0 для элементов слева</li>
</ol>
<br>
<h3>Как выглядит сжатый файл?</h3>
<tab>Биты пишутся в стиле big-endian</tab>
<ol>
  <li>Количество символов в словаре</li>
  <li>Таблица !существующих! символов с частотами их повторения (пишется символ, после него – его частота, без разделителей)</li>
  <li>Кодировка сжатого файла: пишем код для каждого символа изначального файла без разделителей</li>
</ol>
<br>
<h3>Как происходит декодировка?</h3>
В сжатом файле записаны частоты использованных символов. По ним мы восстанавливаем дерево, а также код каждого из символов. Далее проходим по сжатому файлу, восстанавливая каждый из символов исходя из кодировки.
<ul><li>Почему восстановление будет однозначным?</li></ul>
Потому что изначально очередь строится не только исходя из частот символов, но также и исходя из их битового значения (от меньшего к большему). А при перестановке новых элементов в очереди мы ставим в первое попавшееся подходящее место. А т.к. изначальная очередь строится однозначно, то и остальные итерации будут идентичны построению дерева при сжатии файлов.
<br><br>-----<br>
Кажется, где-то в начале сжатого файла я еще писала количество символов в изначальном файле, дабы не записывать лишнего.
